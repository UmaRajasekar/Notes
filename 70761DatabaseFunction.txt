There are different database functions available as listed below:-
1. Aggregate function:-
These functions perform calculations on set of values and return a single value. They are allowed in HAVING clause with the combination of GROUP BY clause of a select statement
You can also use aggregate function in OVER clause, to aggregate on only certain categories of ROW
The select list of SELECT statments

Different Aggregate function
APPROX_COUNT_DISTINCT- evaluates an expression for each row in a group and returns approximate value of unique not null values in a group
AVG
MAX
MIN
SUM
CHECKSUM_AGG - Returns checksum of the group. It ignores NULL values. It can be applied for ALL values and DISTINCT values. This helps in   tracking changes to the field.
COUNT
COUNT_BIG - operates like a COUNT function, only difference is that it returns BigINT instead of INT
GROUPING - specifies whether the specified column expression in a GROUP BY list is aggregated or not. It is mainly used to distinguish        from NULL values returned by ROLLUP,CUBE or GROUPING SETS
GROUPINGID- It computes the level of grouping. It can be used in SELECT, ORDER BY, HAVING clause. The columns in the GROUPING ID should      match exactly the columns in the GROUP BY clause. GROUPING_ID interprets that string as a base-2 number and returns the equivalent        integer.
STDEV - Returns standard derivation of all the values. Ignores NULL values
STDDEVP - Returns standard derivation for population of all values in the specified expression. It ignores NULL values.
VAR - Retruns variance of all the values. Ignores NULL values.
VARP - Returns variance for the population of all the values. Ignores NULL values.

2. Analytic Functions
Analytic Function calculated an aggregate value based on a group of rows. Unlike aggregate function, analytic function returns multiple rows for each group.Use analytic function to compute moving averages, running totals, percentage or top-N results within a group.

Different Analytic Function
CUME_DIST- This function calculated cummualtive distribution of values within a group of values. This calculates the relavtive position    of a specified value in a group of values. The value will be greater that 0 and less than or equal to 1.
FIRST_VALUE - Returns first value in an ordered set of values.
LAST_VALUE - Returns last value in an ordered set of values.
LAG - Returns record from previous row of the result set
LEAD - Returns record from next row of the result set
PERCENTILE_COUNT- Calculates percentile based on a continous distribution of the column value in SQL server
PERCENTILE_DISC - Calcilates percentile for sorted value in a distint rowset or within distinct partition in SQL Server
Notes:- The difference between PERCENTILE_COUNT and PERCENTILE_DISC is that PERCENTILE_COUNT result is not necessary to be equal to specific value in the column. PERCENTILE_COUNT(0.5) will return MEDIAN value of the table.
PERCENTILE_RANK - Calculates the relative rank of the row within a group of rows. This is similar to CUME_DIST, only difference is that CUME_DIST calculates distribution and PERCENTILE RANK calculates rank of that distribution.

3. Collation Function

Different Collation Funtion
Collation Property
COLLATIONPROPERTY( collation_name , property )  -> This function returns property of the specified collation. 'property' can be CodePage, LCID, ComparisionStyle, Version

TERTIARY_WEIGHTS
TERTIARY_WEIGHTS( non_Unicode_character_string_expression ) -> Returns binary string of weights for each character in a non-unicode string expression.

Configuration
These are scalar functions return information about current configuration option settings

Different configuration function
@@DBTS -> Returns currunt timestamp.
@@LANGID -> Returns local language ID of the language that is currently being used. This can also be using variable 'SET LANGUAGE 'Language''
@@LANGUAGE-> Returns language curruntly being used. You can also set language.
@@LOCK_TIMEOUT -> Returns current lock timout settings in milliseconds for the current session. You can also set your own lockout time. This allows an application to set the maximum time that a statement waits on a blocked resource. returns in milliseconds.
@@MAX_CONNECTIONS -> Returns maximum number of user connections allowed  on an SQL server instance.
@@MAX_PRECISION -> Returns precision level used by decimal and number data types 
@@NESTLEVEL -> Returns nesting level of current stored procedure execution(initially 0) on the local server.
@@OPTIONS -> Returns information of current SET operation.
https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/configure-the-user-options-server-configuration-option?view=sql-server-2017
@@OPTIONS returns number in the form of addition of 2 power number as mentioned in the above web page. This helps us to figure on which option is activated.
@@REMSERVER - This enables stored procedure to check the name of the database server from which procedure is running.
@@SERVERNAME - Returns name of local server that is running SQL server
@@SERVICENAME - Returns service name of registry key under which SQL server is running. For default server, it returns 'MSSQLSERVER'.
@@SPID - Returns session ID of the current user.
@@TEXTSIZE - Returns current value of text size. You can also set text size
@@VERSION - Returns system and build information  for the current installation of SQL Server

Conversion
This function helps in datatype casting and conversion

Different conversion functions are listed below:-
a. CAST and CONVERT
This helps in converting one datatype to another. Casting Decimal number as int. Convert, converts datatype into desired datatype
-- CAST Syntax:  
CAST ( expression AS data_type [ ( length ) ] )  
-- CONVERT Syntax:  
CONVERT ( data_type [ ( length ) ] , expression [ , style ] )
The differnce between int and numeric is that int datatype truncates the number and numeric datatype rounds off the number
In convert datatype, char converts binary datatype to character datatype
In convert datatype, binary converts char datatype to binary datatype.
You can cast datetime as date, time and datetime
b. PARSE
Parse is mostly used to convert string data type into number and date/time datatype.
c. TRY_CAST
Retruns a value cast to the specified data type if the casts suceeds; otherwise returns NULL
d. TRY_CONVERT 
Returns a value cast to the specified data type if the casts succeeds; otherwise returns NULL
Whenever CAST or CONVERT is not explicitly permitted, then SQL server throws an error.
Ex:- type cast converting of int datatype to xml datatype is not allowed.
e. TRY_PARSE
Returns the result of expression, translated to a requested data type, or null if casts fails in SQL server.

Crytographic Function
These functions support digital signing, digital signature validation, encryption, and decryption
a. ASYMKEY_ID
SQL server provides options to create aysmetric key. ASYMKEY_ID returns key ID of that particular asymmetric key.
b. ASYMKEYPROPERTY
By taking ASYMKEY_ID as input , it returns algorithm description, SID of an asymmetric key in nvarchar() and binary format
c. CERT_ID
SQL server provides options to create certificate with the help of password or private key. CERT_ID returns certificate ID of that certificate
d. CERTPROPERTY
By taking certID, it can return property as Expiry_Date, Start_Date, Issuer_Name, Cert_Serial_Number, Subject, SID, String_SID
e. CRYPT_GEN_RANDOM
This function returns a random cryptographic, randomly-generated number, generated by Crypto API. Returns a hexadecimal number with a length of specified number byte.
f. EncryptByAsymKey  and DecryptByAsymKey
Above function encrypts a plain text and decrypts the same with the help of asymetric key.
g. DECRYPTBYCERT and ENCRYPTBYCERT
Above function encrypts a plain text and decrypts the same with the help of certificate.
h. ENCRYPTBYKEY and DECRYPTBYKEY
Above function encrypts a plain text and decrypts the same with the help of symmetric key.

CURSOR
@@CURSOR_ROWS- This returns the number of qualifying rows currently in the last cursor opened on the connection.
  Returns negative value if the cursor set is opened asynchronously
  Returns -1 if the cursor is dynamic.
  0 No cursor is opened
  n Returns total number rows in the cursor
@@FETCH_STATUS - Issues status of the last FETCH command issued.
  0 - The fetch statement was successful.
  -1 - The fetch statement was failed or row was beyond the result set.
  -2 - The row fetched is missing
  -9 - The cursor is not performing a fetch operation
CUSROR_STATUS - For given parameters, CURSOR_STATUS shows whether or not a cursor declaration has returned a cursor and result set.
  1 - Cursor returns atleast one row
  0 - The cursor result set is empty
  -1 - The cursor is closed
  -2 - Not applicable
  
Logical Functions:-
1. CHOOSE(array_index,value1,value2,value3)
2. IIF(boolean,true, false)

Ranking Function:-
Ranking function returns a ranking value for each row in the partition. Depending on the function that is used, some rows might recieve the same value as other rows.
1. DENSE_RANK- Returns rank with no gaps in the ranking.
2. NTILE- Distirbutes the rows in an ordered partition into a specified number of groups. If group of 50 statements needs to grouped in 8 grpups, then first 2 groups will have 7 rows and remaining groups will have 6 rows
3. RANK - Returns rank of each row within partition of result set. for example 1, 2, 2, 4, 5
4. ROW_NUMBER- Returns sequencial number and does not have duplicate rank

String Functions
1. ASCII - returns ASCII value of the left most character
2. CHAR - Returns character of the correspinding ASCII value. For any value other than 0-255, it returns NULL.
3. CHARINDEX - Returns starting position of the first argument expression available in second argument expression.
4. CONCAT - Concatenation of strings
5. CONCAT_WS - Concatenates the string with the help of seperator. Both CONCAT and CONCAT_WS ignores NULL
6. SOUNDEX - Returns four character code to evaluate the similarity of two things.
7. DIFFERENCE - Returns integer value measuring the difference between two SOUNDEX function of the string. DIFFERENCE function returns 4    if there are less difference in SOUNDEX function of two string. If there are larger difference, then returns 0.
8. FORMAT - Mostly used to return date/time in desired format. You can also format number as numeric, general and currency format.
9. LEFT - Returns left part of a character string with specified number of characters
10. LEN - Returns length of the string
11. LOWER - Retruns lower case of the string
12. LTRIM - Trims the whitespace of the string
13. UNICODE - Same as ASCII, but returns value in UNICODE standard
14. NCHAR - Same as CHAR (which returns character of ASCII value), instead it returns character UNICODE value
15. PATINDEX - Pattern Index. Returns starting position of first occurence of the pattern in a given string.
16. QUOTENAME - Returns the string in quoted character.
17. Replace - Replaces all the occurence of the string characters
18. Replicate - Replicates the specified string character.
19. STR - Converts character data coverted from numeric
20. STRING_AGG - Concatentes the value of string expression and places seperator values between them.
21. STRING_ESCAPE - Escapes special character in text and returns text with escaped character
22. STRING_SPLIT - Opposite to String aggregate. This splits string into various rows based on the seperator.
23. STUFF - This function inserts a string into another string. It deletes the specified length of the characters in the first string at the start position and then inserts the second string into the first string at the start position.
24. Returns part of the string.

Datatype function
1. DATALENGTH - Returns number of bytes used to represent any expression.
2. IDENT_CURRENT - Returns last identity generated for the table. 
    @@IDENTITY- returns last identity generated for any  table
    SCOPE_IDENTITY - returns last identity generated for any table through insert statements
3. IDENT_INCR - returns increment value of the increment column which is set during creation
4. IDENT_SEED - sreturns seed value of the increment column which is set during creation
5. IDENTITY - This function can be only used while creating a new table using SELECT statements
6. SQL_VARIANT_PROPERTY - SQL variant is the datatype which helps to store all kinds of data type supported by SQL server. It returns property of the column such as BaseType, Precision, Scale, Collation, TotalBytes and maxklength

Date and Time function
@@DATEFIRST - Returns first day which is set in database(by default, it is SUNDAY for us_english. You can also set your own day)
CURRENT_TIMESTAMP - Retruns current database timestamp. Same as GETDATE()
SYSDATETIME - Returns system date and time.
SYSDATETIMEOFFSET - Returns system date and time and also indicates offset from universal timezone
SYSUTCTIME() - Returns universal time zone. Same as GETUTUCDATE()
DATEADD - Helps to add datepart. This can be YEAR, MINUTE, HOUR, DAYOFYEAR, DAY,week minutes, seconds, milliseconds and nanoseconds
DATEDIFF - Helps in getting datedifference of any of the parts YEAR, MINUTE, HOUR, DAYOFYEAR, DAY,week minutes, seconds, milliseconds and nanoseconds
DATEDIFF_BIG - Same as DATEDIFF, only difference is that it returns as Big int.
DATEFROMPARTS - Returns date from year, month and day part.
DATENAME - Returns date part specified in argument as character
DATEPART - Returns date part specified in argument as integer.
DATETIME2FROMPARTS - Has argument of day, month, year, hours, minutes, seconds, fraction and precision and returns datetime2.
DATETIMEFROMPARTS - Has argument of day, month, year, hours, minutes, seconds and milliseconds and returns datetime
DATETIMEOFFSETFROMPARTS - Has argument of day, month, year, hours, minutes, seconds, fraction, hour_offset, minute_offset, precision)
DAY - Same as datepart(day,date)
YEAR - Same as datepart(year, date)
MONTH - Same as datepart(month, date)
EOMONTH - Returns last day of the month.
ISDATE - Returns 1 if its valid date.
SMALLDATETIMEFROMPARTS - Has argument of day, month, year, hours and minutes
SWITCHOFFSET - This is used to switch current time(in the format of datetimeoffset) to different timezone.
TIMEFROMPARTS - Has argument of hours, minutes, seconds, fraction and precision and returns time
TODATETIMEOFFSET - Helps in changing time to different timezone

Joins:-
Nested Loop Join:-
  A nested loops join is particularly effective if the outer input is small and the inner input is preindexed and large.
Merge Joins:-
  If both join inputs are large and the two inputs are of similar sizes, a merge join with prior sorting and a hash join offer similar performance. Join on indexed column on equal number of rows of table.
Hash Joins:-
  Hash joins can efficiently process large, unsorted, nonindexed inputs. They are useful for intemediate results in complex queries.
There are two phases.
  a. Build Phase:-
    It reads rows of smaller table into the memory. It hashes the keys of the rows which will be used for join.
  b. Probe Phase:-
    It reads rows of other table and hashes the keys of the rows which will be used for join. While doing this it checks for the matching rows on hashed keys in the table build in Build phase. Smaller table in memory and larger table in disk is basic rule. If smaller table does not fit in memory it spits to hard drive. DBSPACETEMP configuration parameter is used to stored hashed table in probe phase.
There are three types of hash joins
  1. In-memory hash join.
  2. Grace hash join.
  3. Recursive hash join.

Common Table Expression:-
Specified as temporary named result
It can be used in SELECT, INSERT, UPDATE and DELETE statement and can also be used in CREATE VIEW statements.
Guidelines for using non-recursive CTE:-
A CTE must be followed by SELECT, INSERT, UPDATE and DELETE statement and can also be followed in CREATE VIEW statements.
Multiple CTE query definitions can be defined in a non-recursive CTE. The definition must be combined by one of these set operators: UNION, UNION ALL, EXCEPT and INTERCEPT
CTE can reference itself and previously defined CTEs in the same WITH clause. Forward referencing is not allowed.
Specifying more than one WITH clause is not allowed. Ex:- Subquery cannot have another WITH clause defined with a CTE.
There are few clauses cannot be used in the CTE query definition. ORDER BY, INTO, OPTION, FOR BROWSE
When a CTE 
Guidelines for recursive CTE's:-
A recursive CTE's consist of two query definition. One is anchor member query definition and another is recursive member. You can have multiple anchor member and multiple recursive member. You must define all the anchor member before recursive member.
All the query member of anchor unless they refer themselves.
Anchor members must be combined by one of these set operators: UNION ALL, UNION, INTERSECTION and EXCEPT
The number of columns in the anchor and recursive must be same.
The datatype of the columns in the anchor and recursive member should also be same.
The FROM clause of recursive member should refer only one time to CTE expression name.
The items such as SELECT DISTINCT, GROUP BY, HAVING, Scalar aggragation, TOP, LEFT OUTER JOIN, RIGHT OUTER JOIN, PIVOT and sub-queries are not allowed in recursive member.

Sub-query Rules:-
1. The select list of a subquery introduced with a comparision operator can include only one expression or column name(except that EXISTS and IN operate on "SELECT *" or a list respectively)
2. If the WHERE clause of an outer query includes a column name, it must be a join-compatible with the column in the subquery select list)
3. The ntext, text, image datatypes cannot be used in the select list of queries.
4. Because they must return a single value, subqueries introduced by an unmodified comparision operator(one not followed by the keyword ANY or ALL) cannot include GROUP BY and HAVING clause.
5. The distinct cannot be used in subquery that include GROUP BY.
6. ORDER BY can be specified only when TOP is specified.
7. The COMPUTE and INTO clause cannot be specified.

Control-Of-Flow
1. BEGIN .. END -> encloses a series of T-SQL statements so that a group of T-SQL statements can be executed. 
2. BREAK - exits current while loop. If current while loop is nested with another, then it exits only one WHILE LOOP.
3. CONTINUE - Restarts WHILE loop. Any statements after the CONTINUE keyword are ignored. 
4. IF.. ELSE - Imposes condition on the execution of T-SQL expression. This can include sql_statement or statement_block.
5. GOTO- Alters the flow of execution
6. RETURN - Exits unconditionally from a query or procedure. RETURN is immediate and complete and can be used at any point to exit from a procedure, batch, or statement block. Statement that follow RETURN are not executed.
7. THROW - Raises exception and transfers execution to a catch block of a TRY-CATCH construct.
If a try-catch construct is not available, the statement batch is terminated. The line number and procedure where the exception is raised are set. The severity is set to 16.
If the throw statement is specified without parameters, it must appear inside the CATCH block. This causes caught exception to be raised. Any error that occurs in a THROW statement causes the batch to be terminated
% is the reserved character.
Difference between RAISEERROR and THROW
1. msg_id passed to RAISE error should be available in sys.messages
2. msg_str can contain printf formatting styles
3. The severity parameter specifies the serverity of the exception.
TRY-CATCH - Every try block should immediately follow with Catch block. A try-catch cannot span multiple branches. You can retrive error infomation using ERROR_NUMBER(), ERROR_SEVERITY(), ERROR_STATE(), ERROR_PROCEDURE(), ERROR_LINE(), ERROR_MESSAGE()
Try catch do not trap following conditions:- 
1.Warning and informal messages with severity less than 10.
2.Severity greater than 20
3.Client-interrupt request
4.Session ended by sys admin
Following types of error not handeled in the CATCH statements
1. Compilation errors.
2. Errors that occur during statement-level recompilation
3. Object name resolution errors.
XACT_STATE return -1 if the transaction is uncommittable.
SET XACT_ABORT ON; set the transaction as uncommittable when foriegn key violation happens
WAIT FOR - Blocks the execution of a batch, stored procedure, or transaction until a specified time(TIME) or time interval(DELAY) is reached, or a specified statement modifies or returns at least one row
WHILE - Sets a condition for a repeated execution of an SQL statement or statement block. The statements are executed repeatedly as long as the specified condition is true. The execution of statements in the WHILE loop can be controlled from inside the loop with the BREAK and CONTINUE keywords.

Transaction Statements
1. A Transaction is a single unit of work. If a transaction is sucessful, all of the data modifications made during the transactions are committed and become permanenet part of a database. 
2. If a transaction encounters errors and must be cancelled or rolled back, then all of the data modifications are erased.
SQL Server operates in the following transaction nodes:
1. Autocommit transactions - Each individual statement is a transactions
2. Explicit transactions - Each transaction is explicitly started with the BEGIN TRANSACTION statement and explicitly ended with a COMMIT or ROLLBACK transactions  
3. Implicit transactions - A new transaction is implicitly started when the prior transaction completes, but each transaction is explicitly completed with a COMMIT or ROLLBACK statements.
4. Batch-Scoped transactions - Applicable only to multiple active result sets (MARS), a Transact-SQL explicit pr implicit transaction that starts under a MARS session becomes a batch- scoped transaction. A batch-scoped transaction that is not committed or rolled back when a batch completes is automatically rolled back by SQL server.
Different Transaction Statements:-
1. BEGIN DISTRIBUTED TRANSACTION 
  For example, if BEGIN DISTRIBUTED TRANSACTION is issued on ServerA, the session calls a stored procedure on ServerB and another stored procedure on ServerC. The stored procedure on ServerC executes a distributed query against ServerD, and then all four computers are involved in the distributed transaction. The instance of the Database Engine on ServerA is the originating controlling instance for the transaction.
  The session involved in T-SQL distributed transactions do not get a transaction object they can pass to another session for it to explicitly enlist in the distributed transaction.
  The only way for a remote server to enlist in the transaction is to be the target of a distributed query or a remote stored procedure call.
  The SET option REMOTE_PROC_TRANSACTIONS ON will help to elavate BEGIN transaction into BEGIN DISTRIBUTED transaction when there is a distributed query or remote server call available inside BEGIN TRANSACTION
BEGIN TRANSACTION
1. Providing Transaction name is mandatory when WITH MARK option is available. WITH MARK allows for restoring a transaction log to a named mark.
2. When SET IMPLICIT_TRANSACTIONS is set to ON, a BEGIN TRANSACTION statement creates two nested transactions.
3. Additionally, transaction log marks are necessary if you need to recover a set of related databases to a logically consistent state. Marks can be placed in the transaction logs of the related databases by a distributed transaction
COMMIT TRANSACTION
1. Marks the end of a successful implicit or explicit transaction.
2. If @@TRANCOUNT is 1, COMMIT TRANSACTION makes all data modifications performed since the start of the transaction a permanent part of the database, frees the resources held by the transaction, and decrements @@TRANCOUNT to 0. If @@TRANCOUNT is greater than 1, COMMIT TRANSACTION decrements @@TRANCOUNT only by 1 and the transaction stays active.
3. When used in nested transactions, commits of the inner transactions do not free resources or make thier modifications permanenet. The data modifications are made permanent and resources freed only when the outer transaction is committed.
4. Only one WITH MARK option is applicable in the nested transactions and if multiple MARK statements are available then warning is thrown (not error)
5. In nested transaction, the commit or rollback details of nested transaction will not be committed, but will be committed or rolled back (mentioned in the inner block) post the commit or rollback of outer transaction.
SAVEPOINT
A user can set a savepoint or marker within a transaction
The savepoint defines the location to which a transaction can return if part of the transaction is conditionally cancelled.
If a transaction is rolled back to a savepoint, it must proceed to completion with more Transact-SQL statements if needed and a COMMIT TRANSACTION statement, or it must be canceled altogether by rolling the transaction back to its beginning.
To cancel an entire transaction, use the form ROLLBACK TRANSACTION transaction_name. 
Duplicate savepoint names are allowed in a transaction, but a ROLLBACK TRANSACTION statement that specifies the savepoint name will only roll the transaction back to the most recent SAVE TRANSACTION using the name.
SAVE Transaction is not supported in the distributed transactions

Create and Query database objects:-
Transact-SQL statements can be written and submitted to the database engine in the following ways:-
1. By using SQL Server Management Studio
2. By using sqlcmd utility
3. By connecting from the application you create
a. create database sql statements
create database database_name;
To create a new login
pre-requisite:- create a windows login
1. Create a database login. [create login computer_name\Mary from WINDOWS]
2. To create a user in database [create user Mary for LOGIN [computer_name\Mary]]
Grant and Revoke permission
GRANT EXECUTE ON pr_Names FROM Mary;
REVOKE EXECUTE ON pr_Names FROM Mary;

.WRITE Option in the update statement
Syntax : column.write(expression, @offset, @length)
@offset - Null -> appends text at the end
@length - Null -> Removes all the existing text

OUTPUT option:-
Displays all the data impacted after DML statements such as INSERT, DELETE and UPDATE
<OUTPUT> <DML SELECT STATEMENT ([INSERTED|DELETED].[*|columnname])> <INTO> <tablename|tablevariable 
Remarks
1. The output of the computed column in the OUTPUT clause is not computed.
2. No gurantee in the order of the changes applied
3. OUTPUT Clause will not work on following scenarios
  a. DML statements that reference local partitioned views, distributed partitioned views, or remote tables.
  b. INSERT statements that contain an EXECUTE statement.
  c. Full-text predicates are not allowed in the OUTPUT clause when the database compatibility level is set to 100.
  d. The OUTPUT INTO clause cannot be used to insert into a view, or rowset function.
  e. A user-defined function cannot be created if it contains an OUTPUT INTO clause that has a table as its target.
To prevent nondeterministic behavior, the OUTPUT clause cannot contain the following references:
  a. A column from a view or inline table-valued function when that column is defined by one of the following methods:
    a. A sub-query
    b. A user-defined function that performs user or system data access, or is assumed to perform such access.
    c. A computed column that contains a user-defined function that performs user or system data access in its definition.

Triggers
1. DDL triggers fire in response to a variety of DDL events. These events primarily corresponds to T-SQL statements that start with keywords CREATE, ALTER, DROP, GRANT, DENY, REVOKE or UPDATE Statistics.
Use DDL statements to perform following 
  a. Prevent certain changes to your database schema.
  b. Having something occur in the database in response to a change in your database schema.
  c. Record changes or events in the database schema.
Types of DDL triggers
  a. T-SQL DDL Trigger
  Trigger in response to server-scoped or database-scoped event. statement executed ALTER SERVER CONFIGURATION or DROP TABLE statements executed.
  b. CLR DDL Trigger
  DDL triggers fire only after the DDL statements that trigger them are run. 
  You cannot use INSTEAD OF statements
  DDL trigger do not fire in response to events that affect local or temporary tables and stored procedures
  The information about an event that fires a DDL trigger, and the subsequent changes caused by the trigger, is captured by the EVENTDATA function.
  DDL triggers are not scoped to schemas. Therefore, functions such as OBJECT_ID, OBJECT_NAME,OBJECTPROPERTY and OBJECTPROPERTYEX cannot be used to querying metadata about DDL triggers. Use catalog views instead.
  create DDL and DML trigger comes with the option such as ENCRYPTION and EXECUTE AS CLAUSE
  Create DML trigger on memory optimized table comes with the option such as SCHEMABINDING and NATIVE_COMPILATION
  DDL Trigger has option as FOR and AFTER (CREATE,ALTER, DROP, GRANT, DENY ) wheraes DML statement has option for FOR, INSTEAD OF and AFTER 
EVENTDATA function
Returns an xml value contains time of the event, System process ID, type of event that fired the event
You can also use inserted or deleted tables in trigger to perform some validation, Test for errors and take action based on the error.
Find the difference between the state of the table before and after a data modification and take actions based on that difference.

Mathematical Functions
ABS - returns positive value. Doesnt have any imapact on float values.
ACOS - Function returns angle in radians. Only value from -1 and 1 is valid. For other it returns NULL where ASIN returns DOMAIN error.
Other trignometric expression - ASIN, ATAN, SIN, COS, TAN , COT
ATN2 - Returns the angle in radians between the positive X-axis and the ray of origin to a point 
CIELING- Returns smallest integer greater than or equal to, the specified numerical expression.
DEGREES - Returns degree for the radians passed. Radians will be provided as input to trignometric fuctions.
LOG - returns natural algorithm. The default base is 2.718281828.
POWER - returns the value of specified expression to the specified power.
RADIANS- returns radians for degree entered.
FLOOR - Returns largest integer less than or equal to specfied numberic expression
ROUND - For rounding off.
RAND - assigns random number. Repetitive calls of RAND() with the same seed value return the same results. Returns random float value from 0 to 1.
SIGN - Returns positive(+1), negative(-1) or zero of the specified signed integer
SQRT, SQUARE - Returns square root and square of the number respectively.

Trigger Functions:-
Column Updated-
  1. This function returns a varbinary bit pattern indicating the inserted or updated columns of a table or view
  2. COLUMNS_UPDATED tests for UPDATE or INSERT actions performed on multiple columns. To test for UPDATE or INSERT attempts on one column, use UPDATE().
  3. COLUMNS_UPDATED returns one or more bytes that are ordered from left to right. The rightmost bit of each byte is the least significant bit. The rightmost bit of the leftmost byte represents the first table column in the table, the next bit to the left represents the second column, and so on. 
  4. COLUMN_UPDATED returns multiple byte. One byte is equal to 8 bit. 2^0 (right most of the left most bit is column-1)
  5. You need to use substring function to validate if your column number in the table is more than 8.
TRIGGER_NESTLEVEL
  Returns number of triggers executed for the satement that fired the trigger. This is used to both DML and DDL trigger to find out number of nesting.
UPDATE 
  Returns a Boolean value that indicates whether an INSERT or UPDATE attempt was made on a specified column of a table or view
  UPDATE() is used anywhere inside the body of a Transact-SQL INSERT or UPDATE trigger to test whether the trigger should execute certain actions.

JSON function:
  1. ISJSON -> used to detect whether specified string or column data is in valid JSON format
  2. JSON_VALUE -> used to extract value by providing path of an JSON expression. JSON_VALUE(expression, path). extracts as an object or array. If unable to return object then, error is thrown stating using JSON_QUERY to retrive as Scalar function,
  3. JSON_QUERY -> extracts as scalar function instead of object or array.
  4. JSON_MODIFY -> used to update value of JSON file. Various opreration such as INSERT, APPEND, UPDATE and DELETE JSON value. Need to check if it works for SCALAR function
  
ROWSET function:
  1. OPENDATASOURCE(provider name, init string)
  provider name- Is the name registered as the PROGID of the OLE DB provider used to access the data source. 
  2. OPENQUERY(linked server, query)
  3. OPENROWSET -used in a FROM clause
  4. OPENJSON and OPENXML - Returns JSON and XML data in the tabular format

Replication function:
  PUBLISHINGSERVERNAME- Returns the name of the originating Publisher for a published database participating in a database mirroring session
  
System:
  $PARTITION - $PARTITION.<<Partition name>> (value). Returns the partition number in which a set of partitioning column values would be mapped for any specified partition funtion in SQL server 2017
  @@ERROR - Returns an error number when previous statement encountered an error.
  @@IDENTITY
  @@PACK_RECEIVED - Returns the number of input packets read from the network by SQL server since it was last started.
  @@ROWCOUNT - Returns number of rows affected by last statement
  @@TRANCOUNT - Returns number of begin transaction statement.
  BINARY_CHECKSUM - Returns the binary checksum computed over a row of a table or over a list of expression.BINARY_CHECKSUM and CHECKSUM are similar functions: They can be used to compute a checksum value on a list of expressions, and the order of expressions affects the resultant value. 
  COMPRESS- Compresses the expression
  CONNECTIONPROPERTY - Returns connection property
  CURRENT_REQUEST_ID
  CURRENT_TRANSACTION_ID
  ERROR_LINE
  ERROR_MESSAGE
  ERROR_NUMBER
  ERROR_PROCEDURE
  ERROR_SEVERITY
  ERROR_STATE
  FORMATMESSAGE- Formats the message, before it print. Concats string in place of %s, %i - positive int, %d- negative int
  GET_FILESTREAM_TRANSACTION_CONTEXT - Returns a token that represents the current transaction context of a session. 
  GETANSINULL - Returns the default nullability for the database for this session.
  HOST_ID() - Returns workstation ID
  HOST_NAME()
  ISNULL
  ISNUMERIC
  MIN_ACTIVE_ROWVERSION - returns rowversion values by using MIN_ACTIVE_ROWVERSION.
  NEWID
  NEWSQUENTIALID
  XACT_STATE - Returns user transaction state
